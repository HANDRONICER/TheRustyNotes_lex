Contenido 

Una computadora: 
Artefacto electronico-digital, capaz de recibir INFORMACION, Procesar esa informacion, y Proveer un resultado


Llámese HARDWARE A CUALQUIER EXISTENCIA FISICA DE LA COMPUTADORA.

HARDWARE BASICO DE TODA PC::

MODULOS INTERNOS
MOTHERBOARD (Base sobre la cual se sustenta todo el sistema, es el cimiento principal de nuestra PC y es donde se conectan todos los componentes de HARDWARE Y también ofrece un medio físico por el cual se comunican los componentes en otras palabras la motherboard es la base de todo nuestro edificio (si la PC fuese un edificio))

Almacenamiento de memoria a corto plazo RAM
Almacenamiento de memoria a largo plazo HDD/SDD
FUENTE DE PODER (Proporciona electricidad a todo nuestro sistema u edificio)
PROCESADOR (CPU)
TARJETA GRAFICA (GPU)

(EXTRAS)
VENTILADORES(DISIPADORES DE CALOR)(CPU,GPU,FuenteDePoder)

(PERIFERICOS) (MODULOS EXTERNOS)
TECLADO
PANTALLA
RATON
TARJETA WIFI (puede venir integrada a la placa, venir como un módulo interno O venir como un módulo externo usb)
CARCAZA U TORRE


Llámese SOFTWARE A CUALQUIER EXISTENCIA:
1_CONSIDERADA "NO TANGIBLE" (YA QUE SU PRESENCIA FISICA SOLO EXISTE EN FORMA DE "PULSOS ELECTRICOS"),
2_CAPAZ DE INTERACTUAR CON EL ENTORNO DIGITAL INTERNO DEL COMPUTADOR (DE MANERA LOGICO-ARITMETICA).

Si la computadora fuese un cerebro, Entonces:
el hardware vendría a ser es el "cuerpo" de una computadora.
Y el software vendría a ser el "pensamiento" de una máquina.

LLAMESE "CODIGO" A CUALQUIER EXISTENCIA QUE ESTA PRESENTE DENTRO DE UNA computadora o maquina A NIVEL DE SOFTWARE.

Un programa, es codigo, una aplicación es codigo, una web es codigo, una imagen es codigo, un texto es codigo, una letra es codigo, un punto y coma es codigo.

Siempre que aquello a lo que nombramos exista, como "una unidad" o "conjunto dentro del software", 
y este dentro de una computadora es código.

Si el sofware es el pensamiento de la máquina, entonces el código es cada "idea" de la máquina.

NOTA: La idea y el pensamiento son dos palabras que a menudo se confunden. 

La idea == es equivalente al "CODIGO" 
se refiere a uno o un conjunto de varios "plan(es) ó proceso(s)" que ocurre dentro de la mente/computadora en relación con la finalización de un trabajo o deber.

El pensamiento ==  es equivalente a todo el "SOFTWARE EN GENERAL", 
Se refiere a uno o un conjunto de varios "proceso(s)" que ocurren dentro de la mente/computadora los cuales son vitales, útiles ó necesarios para "el correcto funcionamiento interno de la mente/computador", estos procesos continúan sin cesar.

Asi como un pensamiento puede ser interrumpido pero también puede reanudarse. Un proceso de software puede ser interrumpido pero también reanudarse.

En el momento en que el pensamiento se convierte en una idea o en varias ideas, deja de ser pensamiento y se transforma en idea. 

El pensamiento es algo abierto que sucede sin cesar solo para preservar el funcionamiento interno de la mente, mientras que la idea es algo cerrado con un objetivo o finalidad.

Nota: Una "existencia de código" 
puede referirse a una sola parte dentro de un código, (si se habla con claridad y de manera específica) 
o a Todo el código en si mismo, (siempre que se hable de manera clara y general).

LA FINALIDAD DE UN:
CUERPO/CONTENER EL CONOCIMIENTO ==> ES EL PENSAMIENTO/CONOCIMIENTO/HACE EL SABER ==> ES LA IDEA/SABIDURIA/ ES SABER HACER ==> ACCION/HACER
HARDWARE ==> CONTIENE EL SOFTWARE ==> CONTIENE EL CODIGO ==> REALIZA ACCIONES CON UN OBJETIVO O FINALIDAD.

QUE ES EXACTAMENTE UN CODIGO:

"Un conjunto de datos" los cuales pueden interactuar con la máquina.

Un dato es un valor alfanumérico.
Un dato por si solo carece de significado y es solo un nombramiento, es decir: 21 es solo un "numero" al nombrarlo, A es solo una letra al nombrarla.

Es cuando un dato:
	1) Caso1: Se le otorga al dato un significado especial dentro de un sistema, ya sea funcional o estético que vaya más allá de su nombramiento.
		a. LA LETRA "A" para un archivo, SIGNIFICA "ABIERTO"
	2) Caso 2: Se enlaza con otros dato u otro conjunto de datos, y a esa conjunción se le otorga un significado, ya sea funcional o estetico, que vaya mas alla dde su nombramiento.
		a. EL NUMERO "21" Y LA LETRA "A" == 21G, para un archivo SIGNIFICA "ABIERTO 21 ocasiones". 
	3) Caso 3: Se enlaza como singular o como conjunto, a otra información==*(en adelante "vieja información"), y esa conjunción pasa a tener otro significado (ya sea funcional o estético) del que originalmente se le había dado a la información, Ya sea que el significado de esa vieja información fuese funcional o estético.
		Conjunto de datos alfanumericos: 2-SEP-1945
		SIGNIFICADO: Fecha de término de la segunda guerra mundial.
			DATO + SIGNIFICADO = INFORMACION!

No es necesario acordarse de todos los puntos anteriores,

Solo recuerde que cuando un "dato o conjunto de datos" se les otorga un "significado funcional o estético" pasa ya no a llamarse dato, sino "INFORMACION".

El valor de un DATO siempre está contenido o enlazado DIRECTA Y DEPENDIENTEMENTE a un "apuntador".

Un apuntador no es más que una manera de llamar a cualquier localidad de memoria que guarda datos, una localidad de memoria puede almacenar datos de forma temporal o persistente

La computadora interactúa con los datos e información, para ello necesita acceder a las localidades de memoria.

Los "Tipos de acceso" a cualquier memoria capaz de almacenar cualquier DATOS u INFORMACION son los siguientes:
LECTURA, ESCRITURA, ACTUALIZACION, BORRADO, MOVER, COPIAR

A su vez también es prudente explicar los diferentes tipos o localidades de memoria de almacenamiento disponibles como hardware dentro de la computadora.

Los TIPOS DE "LOCALIDADES DE MEMORIA" disponibles como hardware "BASICOS" siempre incluyen 3 caracteristicas importantes.

1_TAMAÑO U CAPACIDAD DE ALMACENAMIENTO DE DATOS U INFORMACION.
2_TIEMPO PROMEDIO QUE ALMACENAN LOS DATOS EN SU INTERIOR. == AKA. "PERSISTENCIA DE DATOS U INFORMACION".
3_VELOCIDAD QUE POSEE EL HARDWARE DE CADA LOCALIDAD DE MEMORIA PARA ACCEDER A ESOS DATOS == AKA. "VELOCIDAD DE ACCESO A DATOS U INFORMACIÓN".


A continuación se presentan las localidades de memoria básicas, 
comenzando por los tamaños de almacenamiento más grandes, mayor tiempo en la persistencia de datos, y  velocidades de acceso mas lentas y finalmente terminando con los tamaños de almacenamiento de datos mas pequeños, menor tiempo de persistencia de datos y velocidades de acceso mas rapidas.


	• DISCODURO == HDD/SSD
		○ TAMAÑO DE ALMACENAMIENTO: GRANDE
		○ PERSISTENCIA DE DATOS U INFORMACION: LARGA DURACION
		○ VELOCIDAD DE ACCESO: LENTA
	
	• MEMORIA_RAM == DRAM/[SRAM aka. RAM_DDR (Double Data Rate)]
		○ TAMAÑO DE ALMACENAMIENTO: MEDIANO
		○ PERSISTENCIA DE DATOS U INFORMACION: MEDIA DURACION
		○ VELOCIDAD DE ACCESO: RAPIDA
		Tipos de ranura de memoria de una computadora (techlandia.com)
		
		○ CACHE ==>  [CACHE_L == aka. CACHE Level ]
			§ TAMAÑO DE ALMACENAMIENTO: PEQUEÑO
			§ PERSISTENCIA DE DATOS U INFORMACION: CORTA DURACION
			§ VELOCIDAD DE ACCESO: ULTRA_RAPIDA
			
			El tamaño de una cache se mide en: MB ó KB 
			Varios módulos de memoria cache se encuentran incluidos dentro de la memoria RAM, pero la memoria cache no es lo mismo que la memoria RAM ya que el cache es una parte de la RAM, y la memoria RAM es una totalidad conformada por varias partes además de la ya mencionada cache. 
			La cache almacena puntadores los cuales sirven para identificar las localidades de datos a las cuales se quiere acceder, las localidades de datos estan almacenadas directamente en la memoria RAM, sin embargo estas localidades dentro de la RAM no solo pueden almacenar datos e informacion, sino que tambien pueden almacenar en su interior apuntadores de otros dispositivos, como lo son los apuntadores que usa el disco duro para identificar sus datos u información propia ==> los apuntadores de la cache, pueden comunicarse con la CPU (esta comunicación se considera directa con propósito de aprendizaje)
			
			
	• CPU_REGISTROS
		○ TAMAÑO DE ALMACENAMIENTO: MICRO
		○ PERSISTENCIA DE DATOS U INFORMACIÓN: MICRO DURACION
		○ VELOCIDAD DE ACCESO: INSTANTANEA
		
			§ La velocidad de acceso que proveen los registros de una CPU se miden en GHz (gigahertz).
			(y la velocidad de un registro dentro de la CPU es tambien mas rapida que la cache_RAM, 
			los registros son de uso exclusivo para el CPU pero obtienen sus datos gracias a las indicaciones que ofrecen los apuntadores de nuestra Cache_RAM para encontrar asi las localidades de memoria que almacenan nuestra informacion u datos, ya sea que estas localidades de memoria llenas de datos u informacion, se encuentren dentro de nuestra memoria RAM o dentro de nuestro DISCO DURO)
			§ Su tamaño se mide en Bytes o KiloBytes.
			§ Los registros dentro de la cpu son una parte que se encuentra dentro del CPU, estos ayudan a almacenar información. Los registros alimentan el procesador principal interno de la CPU con datos e informacion, el cual procesa esa informacion de manera LOGICO-MATEMATICA para realizar una accion o funcionalidad especifica, luego al terminar el procesamiento, finalmente guarda el resultado de esa accion o funcionalidad realizada dentro de otro REGISTRO, esto con la finalidad de programar la realizacion a futuro de esa accion, para realizar esa accion de manera instantanea ó bien para mantener un historico que compruebe que la acción fue realizada y que sera de utilidad cuando se desee realizar otra accion (con su debido proceso) a futuro ó de manera inmediata.
			

Es necesario entender los conceptos anteriores, para poder llegar a la conclusión de como fluye la información dentro de nuestra computadora gracias a las LOCALIDADES DE MEMORIA Y APUNTADORES: 

a)_la computadora lee un dato u información y dependiendo de en qué localidad memoria se encuentre el dato u información leído(a),
b)_ se desencadenara una acción prevista u pre-planificada en el codigo, 
c)_luego se generara un resultado el cual almacenara dentro a otras localidades de memoria, con su respectivo apuntador que servira de identificador a toda esa información.

La computadora puede acceder, leer y procesar cientos de datos en un corto periodo de tiempo, por tanto es importante definir en el código el conjunto de INSTRUCCIONES que se realizaran previo a realizarlas.

Una instrucción es: cualquier acción de manipulación de datos.

La manipulación de datos incluye pero no solo se limita a:

	1) La "agrupación/estructuración/acoplar" == la union u conjuncion de datos.
	Y La "des-agrupar/des-estructurar/des-acoplar" == el desempaquetamiento u separacion de datos.
	De "valores == datos/informacion" de manera específica ESTO MEDIANTE EL USO DE DataTypes.
	
	2) Realizar operaciones/evaluaciones con los valores == datos/información dentro de los DataTypes ESTO MEDIANTE EL USO DE EXPRESIONES.
	
	3) Realizar operaciones Operaciones de acceso a la memoria: Crear, modificar, borrar, leer, copiar y mover Valores == datos/información dentro de "LOCALIDADES DE MEMORIA". 
	(A la realizacion de cualquier acción de CMBLCM se le llama: allocation of memory/ locacion de memoria).


Al conjunto de INSTRUCCIONES de: 

==> Obtener un dato (Leer un dato desde una localidad externa)
	==> guardar un dato (copiar ese dato desde una localidad externa a otra local)
		==> leer un dato (leer un dato desde la localidad local)
			==> Realizar una acción/funcionalidad con el dato.(evaluación del dato u operación conjunta de nuestro dato actual con otros datos)
					==> proporcionar un valor como resultado: que diga si la operación/evaluación:
					
						◊  pudo finalizar correctamente ==> Se proporciona el valor resultante de la operación.
						◊  no pudo finalizar correctamente ==> Se proporciona un valor de error ( el cual puede o no incluir la descripción de ¿por qué? no finalizo correctamente).
							
						==> guardar el valor resultado en una localidad de memoria.
							==>REPETIR EL PROCESO SI ES NECESARIO
							
A ese conjunto de INSTRUCCIONES específicas se le llama Procesamiento u Proceso de la información. 

Y ese conjunto de INSTRUCCIONES específicas, es el PROCESO MAS SIMPLE existente dentro de una computadora.

Cuando elaboramos un "CODIGO SIMPLE" o un "CONJUNTO DE INSTRUCCIONES simple", se busca siempre realizar un "PROCESO SENCILLO":

==> Obtener un dato
	==> guardar un dato 
		==> leer un dato 
			==> Realizar una acción/funcionalidad con el dato.(evaluación del dato u operación conjunta de nuestro dato actual con otros datos)
				==> proporcionar un valor como resultado
					==> guardar el valor resultado en una localidad de memoria.

Pero prestemos mucha atención en que el objetivo final de todo ese proceso es::: "REALIZAR UNA ACCION u FUNCIONALIDAD" dentro de la computadora.

Asi pues, el objetivo final de TODO CODIGO no es "REALIZAR UN PROCESO", 
Sino que su objetivo final es obtener como resultado: "La REALIZACION DE UNA ACCION u FUNCIONALIDAD" dentro de la computadora.

Resumiendo: un codigo simple realiza un proceso simple, lo que da como resultado la realizacion de una sola accion o funcion.




Pero una computadora no solo hace una sola acción o función, ¡¡sino que puede realizar muchas acciones y funciones!!

Veamos a continuación cómo podemos agrupar varios CODIGOS INDIVIDUALES, cada uno de los cuales hace un proceso, y así obtener como resultado final de esa union/agrupacion: varias acciones u funciones.

Al Codigo que realiza/ejecuta un "proceso sencillo y solitario" == "Conjunto de instrucciones simple", lo denominamos: "TAREA".

El código que realiza un proceso sencillo y solitario llamado tarea, Se le puede UNIR con al menos otro (o varios) código(s) de TAREA(s).

Es entonces cuando se obtiene un conjunto de "CODIGOS DE TAREA" 
(atención: este "conjunto de tareas" contiene dentro de sí varios "conjuntos de instrucciones", mas no contiene varias instrucciones aisladas que se encuentren fuera de un conjunto).

Dentro de este "conjunto de Tareas", Cada Código de Tarea aporta su acción u función sencilla y solitaria.
Realizando así dentro del conjunto no solo uno, sino varios procesos que resultan en acciones y funciones. 

A ese "CONJUNTO DE CODIGOS DE VARIAS TAREAS UNIDAS" se le denomina: PROGRAMA.

En resumen:
Programa ==> agrupación de tareas.
Tarea ==> código simple, que realiza un proceso simple, cuyo resultado es una acción o función simple.


Como podemos ver: Un programa, se compone de tareas y las tareas están compuestas por instrucciones.



__________________________________
__________________________________
__________________________________

Concepto de nombramiento:

Sabemos ahora que una "tarea" == "conjunto de instrucciones".
Ese "conjunto de instrucciones" se crea con motivo de REALIZAR ACCIONES O FUNCIONES sencillas.

Sin embargo colocar a mano instrucciones repetitivas es algo tedioso, ya que ese mismo conjunto de instrucciones puede que necesite colocarse en distintas zonas del codigo para que este realice una accion o funcion.

No es util o practico colocar una y otra y otra y otra vez el mismo codigo dentro de distintas zonas porque:
El codigo crece y crece, y si falla una sola instrucción, hay que buscar entre todos los conjuntos repetidos esa instrucción en particular, y cambiarla a mano una y otra y otra vez, hasta que todo quede igual.

Asi pues se decidio que es util dar un "nombre" a las "tareas" que nosotros codifiquemos, 
Ya que usando un solo "nombre" corto en particular el cual es otorgado a un solo conjunto de instrucciones en particular, se puede representar a todo ese " conjunto de instrucciones"=="tarea" en particular.

Por lo que:

1)Se crea el conjunto de instrucciones
2)Se nombra el conjunto de instrucciones
3)Se puede usar el conjunto de instrucciones

Siendo que por ejemplo:

Imaginemos que La situacion actual es:
1) Se creo y codifico "La tarea con 5999 instrucciones contenidas dentro"
2) Se realizo el nombramiento de esa tarea, nombrandola u identificandola como: "MiTareaConsentida5999" 
3)Se uso el nombramiento asignado a nuestra tarea: especificamente se uso el nombramiento 70 veces colocandolo en 70 zonas que lo requerian. 
4) Se detecto un error dentro de una sola instrucción de las 5999 instrucciones,

Como solucion: podemos ir al conjunto original y corregir esa instrucción erronea por una instrucción correcta, lo que provocara que todas las 70 zonas que usaron el nombramiento, empleen el conjunto de datos original revisado y corregido.



Concepto de objeto de codigo:

La programacion se puede sintetizar en 2 acciones fundamentales:

A)Almacenamiento de valores.
B)Realizar acciones==funciones con valores.

Asi pues existen 2 conjuntos de instrucciones que dan soporte a esa ideologia:

A.1)El conjunto de instrucciones que permite almacenar un valor.
B.1)y el conjunto de instrucciones que permite realizar acciones ó funciones.

Ambas TAREAS tienen una estructura similar, ambas son sencillas de codificar y ambas son de fundamental utilidad, 
Y son tambien ambas tareas las que realizan la creación de un: "Objeto de código".

Sin embargo debido a su "extension" o tamaño, estas tareas se sub-dividieron en un total de 3, las cuales permiten
Crear 2 tipos especificos de objeto de codigo.

______________________


Un valor puede ser lo siguiente: 
	-Un "Dato" o un conjunto de datos
	-Un solo "dato con significado" o un "conjunto de datos con significado" == información.
	-Una "instrucción" o un conjunto de instrucciones


Recordemos que "codigo" es:
"Un conjunto de datos" los cuales pueden interactuar con la máquina.

Recordemos que el concepto de "existencia de codigo" es:  
La forma en que un programador puede referirse a una sola parte dentro de un código, (si se habla con claridad y de manera específica), ó a Todo el código en si mismo, (siempre que se hable de manera clara y general).
Ejemplo de una sola parte puede ser:"un simbolo, una palabra, una linea de codigo, o un conjunto de lineas de codigo==bloque de codigo, un conjunto de instrucciones de codigo==tarea".
Ejemplo de todo el codigo puede ser: "El texto total contenido dentro de un archivo de codigo, un archivo de codigo en particular, un conjunto de archivos de codigo, un programa, un conjunto de programas, o cualquier entidad digital, de software la cual puede existir dentro de un computador.

Asi pues el concepto de "objeto de codigo", no es mas que la manera elegante de referirse a una existencia de codigo en particular la cual es capaz de ser nombrada, para asi, poder ser re-utilizada dentro del codigo empleando su nombramiento.

Pero si aun asi lo requieren: Un objeto de codigo, puede definirse como:

La tarea con identidad propia la cual:
crea una asignación de un "valor ó conjunto de instrucciones" hacia una (o varias localidades de memoria en particular, en caso de que el valor o conjunto de instrucciones a contener sea extenso o muy grande). 

Permitiendo asi que ese "valor/conjunto de instrucciones" habite u se encuentre contenido dentro de esa localidad de memoria

Es importante destacar que luego de que Esa localidad de memoria contenga un valor ó contenga un conjunto de instrucciones, Esa localidad de memoria sera identificada de ahora en adelante mediante un nombre proporcionado por el usuario.

Un "objeto de código" permite que el programador y su código accedan mediante la identidad del objeto de codigo a un valor o conjunto de instrucciones, contenido dentro de una localidad de memoria, sin tener que colocar en cada ocasión el identificador binario de la localidad de memoria completo y en su lugar colocando un nombre asociado a la localidad de memoria.

Existen entonces 2 objetos de codigo fundamentales:

A.2)Contenedor de valor.
B.1)Contenedor de instrucciones.

Estos objetos de codigo se crean mediante los siguientes conjuntos de instrucciones previamente propuestos:

A.1)El conjunto de instrucciones que permite almacenar un valor
B.1)y el conjunto de instrucciones que permite realizar acciones ó funciones.

Sin embargo debido a su complejidad, las tareas A.1 y B.1 se dividieron, cada una en 3 fases/etapas, 
Esas fases/etapas son casi exactamente iguales en ambos casos, sin embargo poseen ligeras variaciones para adaptarse a su proposito, el proposito de A.1 es crear un A.2, y el proposito de B.1 es crear un B.2)


La tarea para crear un "objeto de código: a.2)Contenedor de valor" contiene:

	-3 fases/etapas, las cuales deben ejecutarse progresivamente en el siguiente orden: 
		1.1 Definir una plantilla con las características y formato que se requiere que posea la localidad de memoria. (Declarar el DataType, este paso oficialmente se omite porque la maquina aprovisiona declaraciones DataType de forma predeterminada y solo es necesario de tener en cuenta cuando querramos declarar nuestro propio DataType).
		
		1.2Dar formato a una localidad de memoria según la plantilla que tenemos y asignarle a esa localidad nueva == limpia/sin valores y recién modificada/formateada con nuestra plantilla DataType, un "nombre unico" == "identificador alfanumerico". (Declarar nuestro contenedor de valores y annotar el DataType que se desea asignar)
		
		2 - Meter "Un solo valor" en la localidad de memoria (Inicializar/Instanciar el contenedor asignando valores, los cuales seran contenidos/almacenados dentro de la localidad de memoria asignada al contenedor)
		
		3-  Usar el identificador/nombramiento para poder acceder a la informacion contenida dentro de nuestra localidad de memoria. (Usar la variable)

___

La tarea para crear un "objeto de código: b.2) Contenedor de instrucciones" contiene:

	
	-3 fases/etapas, las cuales deben ejecutarse progresivamente en el siguiente orden: 
	
		1.1 Definir una plantilla con las características y formato que se requiere que posea la localidad de memoria. (Declarar el DataType, este paso oficialmente se omite porque la maquina aprovisiona declaraciones DataType de forma predeterminada, por lo que solo es necesario de tener en cuenta este paso cuando queramos declarar nuestro propio DataType).
		
		1.2 Dar formato a una localidad de memoria según la plantilla que tenemos y asignarle a esa localidad nueva == limpia/sin valores y recién modificada con nuestra plantilla, un "nombre unico" == "identificador alfanumerico". (Declarar nuestro contenedor de instrucciones, 
		en caso de que nuestro contenedor de instrucciones requiera el uso de argumentos: Declarar los contenedores de valor y su respectiva annotacion DataType como parametros
		En caso de que nuestro contenedor de instrucciones requiera el uso de un retorno: Declarar el contenedor de valor y su respectiva annotacion DataType como retorno del contenedor).
		
		2 - Meter "El conjunto de instrucciones o conjunto de tareas" en la localidad de memoria  (Inicializar/Instanciar el contenedor asignando instrucciones, las cuales seran contenidas/almacenadas dentro de la localidad de memoria asignada al contenedor)
		
		3-  Usar el identificador/nombramiento para poder acceder a la informacion contenida dentro de nuestra localidad de memoria. (Usar la variable o Ejecutar la funcion)

//
		
//IMPORTANTE: Las 3 fases (1.2,2,3) para crear esta tarea: "Crear Objeto de codigo:Contenedor de valores", son las unicas que el programador codifica a mano.

Sin embargo, existen instrucciones propias de cada fase,  las cuales son realizadas de manera automatica por la maquina. 

Visualizando la creacion del objeto de codigo: "Contenedor de valores" como un "proceso":

==> Obtener un "valor" cualquiera (Este "valor" lo proporciona el programador)
	==> guardar "el valor" en una localidad de memoria temporal con identificador binario (Esto lo realiza la maquina) 
		==> leer el valor  (esto lo realiza la maquina automaticamente luego de guardar temporalmente "el valor")
			==> Realizar una acción/funcionalidad:
			
			Instrucción A_Se define la plantilla de una localidad de memoria (Esto lo hace el programador)
			
			Instrucción B_Se crea la localidad de memoria tomando como base la plantilla.
			(Esto lo hace el programador, sin embargo es importante comentar que, la maquina tambien realiza instrucciones propias en segundo plano == sin que se noten para ayuda a realizar correctamente esta instrucción.
			Esas instrucciones en segundo plano, se encuentran automatizadas por la maquina y no son accesibles por el programador, ya que, si las toca o le mueve algo a esas instrucciones esto puede ocasionar fallos o corrupcion del codigo ó de la informacion necesaria para que la maquina funcione de manera normal y feliz. Por lo que no es prudente ni saludable pesar todo el tiempo en: "que estara haciendo en segundo plano mi maquina", simplemente_: "dejar que la maquina haga lo suyo si no nos concierne". ) 
			
			C_(El valor es asignado por el programador dentro de la localidad de memoria recien establecida, la cual posee ahora: un nombre unico/identificador_alfanumerico, el valor dentro de si, sus caracteristicas y su formato para que la maquina pueda acceder a el valor correctamente ).
				
				==> proporcionar un valor como resultado (La accion de guardar el valor en una localidad de memoria nombrada/identificada_alfanumericamente: retorna un valor que indica a la maquina que este proceso se realizo correctamente o si existe algun fallo).
					==> guardar el valor resultado en una localidad de memoria. 
						(El valor resultado queda en una localidad de memoria temporal esto lo realiza la maquina y si no se realiza ninguna ninguna otra accion especifica con este valor por parte del usuario, se descarta por parte de la maquina de manera automatica).
						

//En otras palabras: si la maquina omite ciertas instrucciones dentro de un proceso y las realiza en segundo plano: es porque un conjunto de programadores sabe que codificar dentro de esas instrucciones a mano una y otra vez es peligroso para la salud de la máquina.

No piensen en ello a menos que quieran especializarse en lenguaje maquina, o sea necesario acceder al codigo de esos procesos en segundo plano debido a algun error que no es nuestro sino por parte de la propia codificacion interna de la máquina.

//Se omite la realizacion del proceso de un contenedor de instrucciones.

Recapitulando y para concluir: 
Un objeto de código siempre debe pasar por estas 3 etapas realizadas por el programador antes de poder ser usado y ser de utilidad:

1)Planificacion de un objeto de codigo AKA. Declaracion = definicion
2)Creacion de un objeto de codigo AKA. Instanciacion == inicializacion
	2.1 ==> Invocacion == Planificacion y creacion de un objeto de codigo usando la misma instrucción.
3)Uso de un objeto de codigo AKA. llamada

Let x: i32; es un ejemplo valido de una declaracion de codigo ==> Ya que estamos creando un objeto de codigo.
X = 32; es un ejemplo valido de la instanciacion de un objeto de codigo. ==> Ya que estamos llenando ese objeto de codigo??
Println!("imprime valor: {}",x); es un ejemplo valido del uso/llamada de un objeto de codigo.


Notas::::

//importante: un objeto de codigo solo interactua con una unica localidad de memoria, 
POR TANTO solo existe una unica asociacion de esa localidad de memoria hacia un solo valor contenido o un solo conjunto de instrucciones.

	Por ello, en lugar de decir:
Que un objeto de codigo es una asociacion entre una localidad de memoria y el valor o conjunto de instrucciones que contiene dentro de si.
	Es perfectamente válido decir: 
Un objeto de codigo ==> contiene valores ó contiene instrucciones.

//nota: Un objeto de código: Contenedor de valores, puede poseer tambien varios valores dentro de si,
siempre que este conjunto de valores se considere no un conjunto de valores sino un UNICO VALOR que represente a todos los valores.

//nota: Un objeto de código puede poseer varias localidades de memoria dentro de si,
siempre que este conjunto de localidades de memoria se considere: no un conjunto de localidades sino como una UNICA LOCALIDAD que representa a todas las localidades .

//nota: un objeto de codigo:"Contenedor de instrucciones" almacena instrucciones, las cuales pueden crear uno o mas objetos de codigo anidados dentro de si, (Objetos de codigo tales como: Contenedores de valor ó contenedores de instrucciones)

//nota: un objeto de codigo: "contenedor de instrucciones" almacena su contenido dentro de UNA LOCALIDAD DE MEMORIA SOLO DURANTE LA COMPILACION 
Resultando en que un Contenedor de instrucciones es incapaz de almacenar mas contenido o menos contenido mientras se ejecuta en tiempo real, 
Luego de terminar de ejecutarse, el contenedor de instrucciones es capaz de proporcionar un valor de retorno el cual debe ser almacenado dentro de otro objeto de codigo ajeno a nuestro contenedor de instrucciones, (El retorno de algun valor por parte de la instrucción ó bloque de instrucciones, asi como los elementos de codigo dentro de la instrucción ó bloque de instrucciones pueden almacenar valores redirigiendo estos a objetos fuera del contenedor de instrucciones en el cual ESTAN CONTENIDOS siendo asi que NO forman parte instrinseca del Objeto de codigo, sino que solamente se encuentran meramente CONTENIDOS dentro de este: Contenedor de instrucciones.
Ejemplo: una funcion es el ejemplo perfecto de un contenedor de instrucciones, para declarar una funcion y hacer uso de la funcion no es necesario que tenga contenido dentro de si, ya que aunque el contenido del cuerpo de una funcion en puede ser: "valor o conjunto de valores, instrucción o conjunto de intrucciones u objeto de codigo, conjunto de objetos de codigo", no es mas que eso: Contenido el cual es perteneciente a la funcion, Y que no es el contenedor de instrucciones: Funcion dueño del contenido.



//INICIO de zona de trabajo
 


Sí, el bloque de código que constituye el cuerpo de una función en Rust se almacena en memoria. En Rust, como en muchos otros lenguajes de programación, el código fuente se compila en instrucciones de máquina que finalmente se almacenan en la memoria ejecutable del programa.
Cuando compilas un programa Rust, el compilador traduce tu código fuente a instrucciones de bajo nivel específicas de la arquitectura de la máquina objetivo. Estas instrucciones, junto con los datos estáticos y otros elementos necesarios, se organizan en el ejecutable del programa, que se carga en la memoria cuando se ejecuta.
El código de una función, junto con otras secciones del programa, como los datos estáticos, las variables globales, etc., se almacena en la memoria del programa durante su ejecución. Cuando la función es llamada, el control se transfiere a la ubicación de memoria que contiene el código de la función para su ejecución.
En resumen, el código de las funciones en Rust, después de la compilación, se almacena en la memoria del programa y se ejecuta desde allí cuando se llama a la función.

Desde <https://chat.openai.com/c/f4ac0e43-324c-43bf-a815-1e749b8acba8> 



//Estoy equivocado??? NO, pero es necesario parafrasear la informacion previa con la siguiente informacion:

La definicion/Declaracion de un objeto de codigo es cuando codificamos las caracteristicas de un objeto.

Let x: i32; es un ejemplo valido de una declaracion de codigo ==> Ya que estamos creando un objeto de codigo.
X = 32; es un ejemplo valido de la instanciacion de un objeto de codigo. ==> Ya que estamos llenando ese objeto de codigo??
Println!("imprime valor: {}",x); es un ejemplo valido del uso/llamada de un objeto de codigo.

Podrias por favor definir y diferenciar los siguientes conceptos de programacion, las definiciones creadas deben ser aplicables a cualquier lenguaje de codigo existente: "definicion","declaracion", "instanciacion", "inicializacion", "invocacion", "llamada"
ChatGPT
ChatGPT
Claro, aquí tienes definiciones generales para esos conceptos de programación que deberían ser aplicables a cualquier lenguaje de programación:
1. Definición:
	• Definición se refiere al acto de especificar la estructura, tipo o comportamiento de un elemento en el código.
	• Por ejemplo, la definición de una función incluiría su nombre, parámetros y tipo de retorno.
2. Declaración:
	• Declaración es el acto de asociar un identificador/nombramiento a algun tipo de dato o estructura, pero no necesariamente asignarle un valor.
	• Por ejemplo, la declaración de una variable especifica su tipo, pero no le asigna un valor.
3. Instanciación:
	• Instanciación se refiere al proceso de crear una instancia de una clase u objeto, basándose en su definición.
	• En el contexto de variables, puede significar asignar un valor a una variable después de declararla.
4. Inicialización:
	• Inicialización implica asignar un valor inicial a una variable en el momento de su creación o después de su declaración.
	• Es común que la inicialización ocurra durante la instanciación, pero no siempre es el caso.
5. Invocación:
	• Invocación se refiere a la ejecución de una función o método. Es el acto de llamar a la funcionalidad definida por el código.
	• En la invocación de funciones, se proporcionan los argumentos necesarios y se ejecuta el código contenido en la función.
6. Llamada:
	• Llamada es un término similar a la invocación y se utiliza para referirse al acto de solicitar la ejecución de una función o método.
	• Al igual que con la invocación, implica proporcionar los argumentos requeridos para que la función realice su tarea.
Estas definiciones proporcionan una base general que es aplicable a una variedad de lenguajes de programación. Sin embargo, ten en cuenta que algunos términos pueden tener matices específicos según el contexto del lenguaje de programación en el que se utilicen.

Desde <https://chat.openai.com/c/f4ac0e43-324c-43bf-a815-1e749b8acba8> 
Sí, puedo corroborar la afirmación sobre instanciación en el contexto general de programación:
Instanciación se refiere al proceso de crear una instancia de una clase u objeto, basándose en su definición.
En el contexto de variables, cuando hablamos de instanciación, nos referimos al acto de crear una instancia específica de una variable basada en su tipo o definición. En algunos lenguajes de programación, la instanciación de una variable implica asignarle un valor específico, lo cual puede ocurrir al mismo tiempo que se declara la variable o en un momento posterior. En el caso de tipos de datos más complejos, como objetos o clases, la instanciación implica crear un nuevo objeto basado en la definición de la clase.
Es importante señalar que el término "instancia" a menudo se asocia más estrechamente con la creación de objetos a partir de clases en la programación orientada a objetos. Sin embargo, en un sentido más general, puede aplicarse a la creación de cualquier variable o entidad basada en su definición.

Desde <https://chat.openai.com/c/f4ac0e43-324c-43bf-a815-1e749b8acba8> 

Sí, puedo corroborar la definición proporcionada para "Declaración":
Declaración:
• Declaración es el acto de asociar un identificador/nombramiento a algún tipo de dato o estructura, pero no necesariamente asignarle un valor.
• Por ejemplo, la declaración de una variable especifica su tipo, pero no le asigna un valor.
Según esta definición, una declaración se centra en establecer la existencia y tipo de un identificador sin necesariamente asignar un valor específico en el momento de la declaración.
Respecto a la segunda pregunta:
En base a la definición proporcionada, una declaración no sería lo mismo que una instanciación. La declaración se refiere a la asociación de un identificador a un tipo de dato o estructura sin necesariamente asignar un valor, mientras que la instanciación implica la creación de una instancia específica basada en esa declaración y, en muchos casos, incluye la asignación de un valor inicial.
En términos más sencillos, la declaración establece la existencia y tipo de una entidad, mientras que la instanciación crea una instancia específica de esa entidad, a menudo asignándole un valor.

Desde <https://chat.openai.com/c/f4ac0e43-324c-43bf-a815-1e749b8acba8> 

Voy a revisar las definiciones y afirmaciones proporcionadas. Hasta donde he revisado, las definiciones y afirmaciones proporcionadas parecen ser correctas y coherentes:
7. Definición:
	• La definición se refiere al acto de especificar la estructura, tipo o comportamiento de un elemento en el código. Esta definición es precisa y aplicable en diferentes contextos de programación.
8. Declaración:
	• La declaración se refiere al acto de introducir un identificador al programa y asociarle un tipo de dato o estructura, sin necesariamente asignarle un valor. Esta definición también es precisa y concisa.
9. Instanciación:
	• La instanciación se refiere al proceso de crear una instancia de una clase u objeto, basándose en su definición. En el contexto de variables, puede significar asignar un valor a una variable después de declararla. Esta afirmación es correcta y destaca la creación de instancias específicas.
10. Inicialización:
	• La inicialización implica asignar un valor inicial a una variable en el momento de su creación o después de su declaración. Esta definición es clara y alineada con el uso común del término.
11. Invocación:
	• La invocación se refiere a la ejecución de una función o método. Es el acto de llamar a la funcionalidad definida por el código. Esta definición es precisa y se ajusta al contexto de funciones y métodos.
12. Llamada:
	• La llamada es un término similar a la invocación y se utiliza para referirse al acto de solicitar la ejecución de una función o método. Esta definición es correcta y complementaria a la de invocación.
No he identificado errores en las definiciones o afirmaciones proporcionadas. Si tienes alguna pregunta adicional o necesitas más aclaraciones, estaré encantado de ayudarte.

Desde <https://chat.openai.com/c/f4ac0e43-324c-43bf-a815-1e749b8acba8> 




Aquí están los ejemplos completos para cada concepto en la tabla:
13. Definición:
	• Definición de una estructura (struct) en Rust:

rustCopy code
// Definición de un tipo de dato
struct Point {
    x: f64,
    y: f64,
};
14. Declaración:
	• Declaración de variables basadas en la definición:

rustCopy code
// Declaración de variables basadas en la definición
let origin: Point = Point { x: 0.0, y: 0.0 };
let destination: Point = Point { x: 10.0, y: 5.0 };
15. Instanciación:
	• Instanciación de variables basadas en la definición:

rustCopy code
// Instanciación de variables basadas en la definición
let my_point = Point { x: 8.0, y: 12.0 };
let another_point = Point { x: -5.0, y: 2.5 };
16. Inicialización:
	• Inicialización de variables en el momento de la declaración:

rustCopy code
// Inicialización de variables en el momento de la declaración
let radius: f64 = 5.0;
let name: &str = "John";
17. Invocación:
	• Invocación de una función con argumentos:

rustCopy code
// Invocación de una función con argumentos
let result = add(2, 3);
18. Llamada:
	• Llamada a una función:

rustCopy code
// Llamada a una función
greet("World");

Desde <https://chat.openai.com/c/f4ac0e43-324c-43bf-a815-1e749b8acba8> 



Desde <https://chat.openai.com/c/f4ac0e43-324c-43bf-a815-1e749b8acba8> 



1)Planificacion del objeto de codigo
AKA. Definicion/Declaracion == ES LA "ESTRUCTURACION/PLANIFICACION" DE un objeto de  CODIGO "INERTE/INACTIVO"

	Dicho de otra manera: 
	PARA CONTENEDORES DE VALOR:
	EN OTRAS PALABRAS PLANIFICAMOS LAS CARACTERISTICAS DE NUESTRA LOCALIDAD DE MEMORIA, ESPECIFICANDO el  FORMATO del valor que contendra asi como tambien las CARACTERISTICAS y comportamientos de ese valor, REALIZANDO ASI UNA "PLANTILLA" DE UN POSIBLE "CONTENEDOR DE VALOR".
	
	
	PARA Contenedores de INSTRUCCIONES DE CODIGO.
	En esta fase, tambien: "PLANIFICAMOS LAS CARACTERISTICAS DE NUESTRA "INSTRUCCIÓN" u Bloque de Instrucciones DE CODIGO EJECUTABLE" (previo a ejecutar esa instrucción)
	
	
	Una Definicion/Declaracion siempre es un DataType??? NO!
	
	//A esta Planificacion/Estructuracion/plantilla se le denomina con el nombre de:  Definición de un contenedor de valores, Al cual se le asigna durante su declaracion:
	DataType, Nombramiento y el valor a contener.
	(Veremos a detalle que es un "DataType" y que es un "contenedor de valores" y como se diferencia este de "localidad de memoria", por favor mantengan en su memoria estos nombres pero no se distraigan con ello).
	
	Ejemplo de de la creacion de una declaracion de un objeto de codigo: Definicion DataType.
	// Colocar aquí la definicion del objeto de codigo: DataType i32.
	


2)Creacion del objeto de codigo, 
AKA. Instanciacion/INICIALIZACION (tambien se usa el termino de "llamada" aunque su uso es erroneo") == Es la "CREACION" DE un objeto de CODIGO "VIVO" a partir de una definición/declaración.
	
	Dicho de otra manera: CREAMOS UN "CONTENEDOR de VALOR", con su formato, caracteristicas y comportamientos ya presentes,  y acto seguido asociamos un nombre que identifique de forma unica este "contenedor de valor".
	
	Directamente cuando asociamos un nombre a un "Contenedor de valor" este deja inmediatamente de ser una posibilidad, y se convierte en algo real y manipulable dentro de nuestro programa.
	
	A pesar de ya poder contener datos en su interior, Durante la declaracion TODAVIA NO INCLUIMOS UN VALOR dentro de este Objeto de codigo, siendo que este objeto de codigo se encuentra "incompleto". (Siempre y cuando este objeto de codigo sea un "contenedor de valor" y no una instrucción)
	¿Existen entonces 2 clases de objeto de codigo principales? Contenedor de valor e instrucción/bloque de instrucciones?
	
	Durante una inicializacion/instanciacion: ya incluimos un valor dentro del objeto de codigo, siendo que se completan todas las condiciones para que se considere un objeto de codigo completo
	
	//Una instancia de codigo siempre es independiente de la declaración a partir de la cual se creó.
	
	Ejemplo de de la creacion de la instancia de un objeto de codigo: "Contenedor de valor" de categoria: "Variable", luego a esa instancia le asignamos un valor.:
	// x = 128;
	
	
	a.  Invocación ==> Se crea la instancia de nuestro objeto de codigo e inmediatamente despues de crearse, dentro de la misma instrucción con la cual creamos la instancia del objeto de codigo, se realizar el llenado de nuestro objeto de codigo con valores.
		
	
	
	Invocación es una declaracion con pasos extra ==> Se crea la declaracion de nuestro objeto de codigo, y en lugar de realizar una asignacion a la instancia de nuestro objeto de codigo por separado para asignar un valor, se realiza la asignacion de un valor dentro de la misma instrucción de declaracion.
	
	Siendo que se realizan los 2 pasos: Declaracion y asignacion de un valor a la instancia del codigo, directamente dentro de la declaracion el valor a asignar, por lo que ya no es necesario realizar el paso de realizar el llenado de nuestro objeto de codigo con valores. 
	
	Ejemplo de invocacion: 
	Let x = 
	
	
	
	
3)Uso del objeto de codigo
AKA. Llamada == Es el uso de nuestro "Contenedor de valor u Objeto de codigo".
Al llenar nuestro objeto de codigo con un valor, (estamos haciendo uso de nuestro "objeto de codigo")
Al leer la informacion dentro de nuestro objeto de codigo, (estamos haciendo uso de nuestro "objeto de codigo")
Al modificar la informacion dentro de nuestro objeto de codigo, (estamos haciendo uso de nuestro "objeto de codigo")

Y al realizar cualquier interaccion con nuestro OBJETO DE CODIGO instanciado en general, (estamos haciendo uso de nuestro "objeto de codigo")



//FIN de zona de trabajo



//Conceptos relevantes pero no incluidos dentro de la explicacion principal.

Un objeto de codigo realiza los siguientes pasos para realizar un proceso:

1) Se define una instrucción.
2) Se define o se acepta una entrada.
3) Se realiza un proceso (Cuando un valor interactua directamente con una instrucción se dice que esta realizando un proceso)
4) Se genera una salida (y SIEMPRE al finalizar un proceso se genera una "salida", Una salida es un "nuevo valor==dato/informacion" resultante de un proceso.)

Finalmente resumiremos todo lo que acabamos de ver en un solo parrafo:

Un programa informático o programa de computadora es: una "secuencia de varias TAREAS".

Cada Tarea se interpreta y se ejecuta en secuencia para obtener como resultado una acción o funcionalidad compleja == Conjunto de varias acciones o funciones simples.

Un solo "Conjunto de tareas" se encuentra conformado en su interior por varios conjuntos de  "instrucciones u órdenes".

Un solo "conjunto de instrucciones u órdenes" tiene como finalidad realizar "una sola acción o función" dentro de la máquina.

Cada instrucción realiza una interacción con un "Valor" los cuales son diversos y distintos.

Un valor puede y debe ser almacenado dentro de un "Objeto de Codigo". (Excepto cuando los datos se consideren temporales o descartables.)
 


Desde <https://es.wikipedia.org/wiki/Programa_inform%C3%A1tico> 



